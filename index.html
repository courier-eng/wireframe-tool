<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ワイヤーフレーム作成ツール</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 警告を少なくするために基本的なスタイルを追加 */
        * {
            box-sizing: border-box;
        }
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef } = React;

        const WireframeBuilder = () => {
          const [elements, setElements] = useState([]);
          const [selectedElement, setSelectedElement] = useState(null);
          const [draggedElement, setDraggedElement] = useState(null);
          const [isDrawing, setIsDrawing] = useState(false);
          const [startPos, setStartPos] = useState({ x: 0, y: 0 });
          const [resizing, setResizing] = useState(null);
          const [canvasSize, setCanvasSize] = useState({ width: 1200, height: 800 });
          const [zoom, setZoom] = useState(1);
          
          // グリッド機能の追加
          const [showGrid, setShowGrid] = useState(true);
          const [gridSize, setGridSize] = useState(20);
          
          // 選択中の要素タイプを記憶（新機能）
          const [selectedElementType, setSelectedElementType] = useState('rectangle');
          
          const canvasRef = useRef(null);

          // 追加可能な要素タイプ（拡張版）
          const elementTypes = [
            { type: 'rectangle', label: '四角形' },
            { type: 'text', label: 'テキスト' },
            { type: 'button', label: 'ボタン' },
            { type: 'radio', label: 'ラジオボタン' },
            { type: 'checkbox', label: 'チェックボックス' },
            { type: 'input', label: '入力フィールド' },
            { type: 'image', label: '画像' },
          ];

          // キャンバスサイズのプリセット
          const canvasPresets = [
            { name: 'デスクトップ (1920x1080)', width: 1920, height: 1080 },
            { name: 'デスクトップ (1440x900)', width: 1440, height: 900 },
            { name: 'デスクトップ (1200x800)', width: 1200, height: 800 },
            { name: 'タブレット (1024x768)', width: 1024, height: 768 },
            { name: 'タブレット (768x1024)', width: 768, height: 1024 },
            { name: 'モバイル (375x667)', width: 375, height: 667 },
            { name: 'モバイル (414x896)', width: 414, height: 896 },
            { name: 'モバイル (360x640)', width: 360, height: 640 },
            { name: 'カスタム', width: 0, height: 0 },
          ];

          // グリッドサイズのプリセット
          const gridSizeOptions = [10, 15, 20, 25, 30, 40, 50];

          // グリッドパターンのSVGを生成
          const generateGridPattern = () => {
            const patternId = `grid-pattern-${gridSize}`;
            return `url("data:image/svg+xml,%3Csvg width='${gridSize}' height='${gridSize}' xmlns='http://www.w3.org/2000/svg'%3E%3Cdefs%3E%3Cpattern id='${patternId}' width='${gridSize}' height='${gridSize}' patternUnits='userSpaceOnUse'%3E%3Cpath d='M ${gridSize} 0 L 0 0 0 ${gridSize}' fill='none' stroke='%23ADD8E6' stroke-width='1' opacity='0.5'/%3E%3C/pattern%3E%3C/defs%3E%3Crect width='100%25' height='100%25' fill='url(%23${patternId})'/%3E%3C/svg%3E")`;
          };

          // 新しい要素を追加（キャンバス範囲内に制限）
          const addElement = (type, x, y, width = 100, height = 50) => {
            // タイプごとのデフォルトサイズ調整
            let defaultWidth = width;
            let defaultHeight = height;
            
            switch(type) {
              case 'radio':
              case 'checkbox':
                defaultWidth = Math.max(width, 120); // 最小幅を確保
                defaultHeight = Math.max(height, 30); // 最小高さを確保
                break;
              case 'button':
                defaultWidth = Math.max(width, 80);
                defaultHeight = Math.max(height, 35);
                break;
              case 'input':
                defaultWidth = Math.max(width, 150);
                defaultHeight = Math.max(height, 35);
                break;
              case 'image':
                defaultWidth = Math.max(width, 100);
                defaultHeight = Math.max(height, 80);
                break;
            }
            
            // キャンバス範囲内に収める
            const constrainedX = Math.max(0, Math.min(x, canvasSize.width - defaultWidth));
            const constrainedY = Math.max(0, Math.min(y, canvasSize.height - defaultHeight));
            const constrainedWidth = Math.min(defaultWidth, canvasSize.width - constrainedX);
            const constrainedHeight = Math.min(defaultHeight, canvasSize.height - constrainedY);
            
            // タイプごとのデフォルトコンテンツ
            let defaultContent = '';
            switch(type) {
              case 'rectangle': defaultContent = '四角形'; break;
              case 'text': defaultContent = 'テキスト'; break;
              case 'button': defaultContent = 'ボタン'; break;
              case 'radio': defaultContent = 'ラジオボタン'; break;
              case 'checkbox': defaultContent = 'チェックボックス'; break;
              case 'input': defaultContent = 'input'; break;
              case 'image': defaultContent = '画像'; break;
              default: defaultContent = '';
            }
            
            const newElement = {
              id: Date.now() + Math.random(), // より一意なIDを生成
              type,
              x: constrainedX,
              y: constrainedY,
              width: constrainedWidth,
              height: constrainedHeight,
              content: defaultContent,
            };
            
            console.log('Adding new element:', newElement);
            setElements([...elements, newElement]);
            return newElement;
          };

          // キャンバス上でのマウスダウン
          const handleCanvasMouseDown = (e) => {
            const canvasRect = canvasRef.current.getBoundingClientRect();
            const x = (e.clientX - canvasRect.left) / zoom;
            const y = (e.clientY - canvasRect.top) / zoom;

            // キャンバス範囲外のクリックは無視
            if (x < 0 || x > canvasSize.width || y < 0 || y > canvasSize.height) {
              return;
            }

            // リサイズハンドルのチェック
            if (selectedElement) {
              const handle = getResizeHandle(selectedElement, x, y);
              if (handle) {
                setResizing({
                  elementId: selectedElement.id,
                  handle,
                  startX: x,
                  startY: y,
                  originalElement: { ...selectedElement }
                });
                return;
              }
            }

            // 既存の要素を選択
            let found = false;
            for (let i = elements.length - 1; i >= 0; i--) {
              const el = elements[i];
              if (
                x >= el.x &&
                x <= el.x + el.width &&
                y >= el.y &&
                y <= el.y + el.height
              ) {
                console.log('Selecting element on mousedown:', el);
                setSelectedElement({ ...el }); // 新しいオブジェクトとして設定
                setDraggedElement({ ...el, offsetX: x - el.x, offsetY: y - el.y });
                found = true;
                break;
              }
            }

            if (!found) {
              console.log('No element found, clearing selection');
              setSelectedElement(null);
              setStartPos({ x, y });
              setIsDrawing(true);
            }
          };

          // マウス移動
          const handleCanvasMouseMove = (e) => {
            const canvasRect = canvasRef.current.getBoundingClientRect();
            const x = (e.clientX - canvasRect.left) / zoom;
            const y = (e.clientY - canvasRect.top) / zoom;

            // リサイズ処理
            if (resizing) {
              const original = resizing.originalElement;
              const dx = x - resizing.startX;
              const dy = y - resizing.startY;
              
              let newProps = {};
              
              switch (resizing.handle) {
                case 'tl': // 左上
                  newProps = {
                    x: Math.max(0, original.x + dx),
                    y: Math.max(0, original.y + dy),
                    width: Math.max(10, original.width - dx),
                    height: Math.max(10, original.height - dy)
                  };
                  break;
                case 'tr': // 右上
                  newProps = {
                    y: Math.max(0, original.y + dy),
                    width: Math.max(10, Math.min(canvasSize.width - original.x, original.width + dx)),
                    height: Math.max(10, original.height - dy)
                  };
                  break;
                case 'bl': // 左下
                  newProps = {
                    x: Math.max(0, original.x + dx),
                    width: Math.max(10, original.width - dx),
                    height: Math.max(10, Math.min(canvasSize.height - original.y, original.height + dy))
                  };
                  break;
                case 'br': // 右下
                  newProps = {
                    width: Math.max(10, Math.min(canvasSize.width - original.x, original.width + dx)),
                    height: Math.max(10, Math.min(canvasSize.height - original.y, original.height + dy))
                  };
                  break;
                case 't': // 上
                  newProps = {
                    y: Math.max(0, original.y + dy),
                    height: Math.max(10, original.height - dy)
                  };
                  break;
                case 'r': // 右
                  newProps = {
                    width: Math.max(10, Math.min(canvasSize.width - original.x, original.width + dx))
                  };
                  break;
                case 'b': // 下
                  newProps = {
                    height: Math.max(10, Math.min(canvasSize.height - original.y, original.height + dy))
                  };
                  break;
                case 'l': // 左
                  newProps = {
                    x: Math.max(0, original.x + dx),
                    width: Math.max(10, original.width - dx)
                  };
                  break;
              }
              
              // 上限制約を適用
              if (newProps.x !== undefined && newProps.width !== undefined) {
                if (newProps.x + newProps.width > canvasSize.width) {
                  newProps.width = canvasSize.width - newProps.x;
                }
              }
              
              if (newProps.y !== undefined && newProps.height !== undefined) {
                if (newProps.y + newProps.height > canvasSize.height) {
                  newProps.height = canvasSize.height - newProps.y;
                }
              }
              
              const updatedElements = elements.map((el) => {
                if (el.id === resizing.elementId) {
                  return { ...el, ...newProps };
                }
                return el;
              });
              
              setElements(updatedElements);
              
              // 選択中の要素も更新
              if (selectedElement && selectedElement.id === resizing.elementId) {
                const updatedSelectedElement = updatedElements.find(el => el.id === selectedElement.id);
                setSelectedElement(updatedSelectedElement);
              }
              
              return;
            }

            if (draggedElement && !draggedElement.isPreview) {
              // 要素をドラッグ（キャンバス範囲内に制限）
              const newX = Math.max(0, Math.min(x - draggedElement.offsetX, canvasSize.width - draggedElement.width));
              const newY = Math.max(0, Math.min(y - draggedElement.offsetY, canvasSize.height - draggedElement.height));
              
              const updatedElements = elements.map((el) => {
                if (el.id === draggedElement.id) {
                  return {
                    ...el,
                    x: newX,
                    y: newY,
                  };
                }
                return el;
              });
              setElements(updatedElements);
              
              // 選択中の要素も更新
              if (selectedElement && selectedElement.id === draggedElement.id) {
                const updatedSelectedElement = updatedElements.find(el => el.id === selectedElement.id);
                setSelectedElement(updatedSelectedElement);
              }
            } else if (isDrawing) {
              // 新しい要素を描画中（キャンバス範囲内に制限）
              const width = x - startPos.x;
              const height = y - startPos.y;
              
              // プレビュー要素を更新
              setDraggedElement({
                type: selectedElementType, // 選択中の要素タイプを使用
                x: startPos.x,
                y: startPos.y,
                width: width,
                height: height,
                isPreview: true,
              });
            }
          };

          // マウスアップ
          const handleCanvasMouseUp = () => {
            if (resizing) {
              setResizing(null);
              return;
            }
            
            if (isDrawing && draggedElement?.isPreview) {
              // サイズが極小でなければ新しい要素を追加
              if (Math.abs(draggedElement.width) > 10 && Math.abs(draggedElement.height) > 10) {
                const x = draggedElement.width > 0 ? draggedElement.x : draggedElement.x + draggedElement.width;
                const y = draggedElement.height > 0 ? draggedElement.y : draggedElement.y + draggedElement.height;
                const width = Math.abs(draggedElement.width);
                const height = Math.abs(draggedElement.height);
                
                const newEl = addElement(selectedElementType, x, y, width, height); // 選択中の要素タイプを使用
                setSelectedElement(newEl);
              }
            }
            
            setDraggedElement(null);
            setIsDrawing(false);
          };

          // 要素をパレットからキャンバスにドラッグして追加
          const handleElementDragStart = (type, e) => {
            e.dataTransfer.setData('elementType', type);
            setSelectedElementType(type); // ドラッグ開始時に選択タイプを更新
            console.log('Drag started with type:', type);
          };

          const handleCanvasDragOver = (e) => {
            e.preventDefault();
          };

          const handleCanvasDrop = (e) => {
            e.preventDefault();
            const type = e.dataTransfer.getData('elementType');
            const canvasRect = canvasRef.current.getBoundingClientRect();
            const x = (e.clientX - canvasRect.left) / zoom;
            const y = (e.clientY - canvasRect.top) / zoom;
            
            // キャンバス範囲内に要素を追加
            if (x >= 0 && x <= canvasSize.width && y >= 0 && y <= canvasSize.height) {
              const newEl = addElement(type, x, y);
              console.log('New element added via drop:', newEl);
              setSelectedElement({ ...newEl }); // 新しいオブジェクトとして設定
            }
          };

          // キャンバスサイズを変更
          const handleCanvasSizeChange = (preset) => {
            console.log('Canvas size changing to:', preset);
            let newWidth = preset.width;
            let newHeight = preset.height;
            
            if (preset.name === 'カスタム') {
              const width = parseInt(prompt('幅を入力してください:', canvasSize.width));
              const height = parseInt(prompt('高さを入力してください:', canvasSize.height));
              if (width > 0 && height > 0) {
                newWidth = width;
                newHeight = height;
              } else {
                return; // キャンセルされた場合
              }
            }
            
            setCanvasSize({ width: newWidth, height: newHeight });
            
            // 既存の要素がキャンバス外に出た場合は調整
            const updatedElements = elements.map(el => ({
              ...el,
              x: Math.max(0, Math.min(el.x, newWidth - el.width)),
              y: Math.max(0, Math.min(el.y, newHeight - el.height)),
              width: Math.min(el.width, newWidth - el.x),
              height: Math.min(el.height, newHeight - el.y)
            }));
            setElements(updatedElements);
            
            // 選択中の要素も更新
            if (selectedElement) {
              const updatedSelected = updatedElements.find(el => el.id === selectedElement.id);
              if (updatedSelected) {
                setSelectedElement({ ...updatedSelected });
              }
            }
          };

          // 選択された要素を削除（シンプル版）
          const deleteSelectedElement = () => {
            console.log('Deleting selected element:', selectedElement);
            
            if (!selectedElement) {
              console.log('No selected element to delete');
              return;
            }
            
            // 削除実行
            const newElements = elements.filter(el => el.id !== selectedElement.id);
            console.log('Element deleted, new count:', newElements.length);
            
            setElements(newElements);
            setSelectedElement(null);
          };

          // 選択された要素をコピー
          const copySelectedElement = () => {
            console.log('Copying selected element:', selectedElement);
            
            if (!selectedElement) {
              console.log('No selected element to copy');
              return;
            }
            
            // コピーする位置を計算（元の位置から少しずらす）
            const offsetX = 20;
            const offsetY = 20;
            let newX = selectedElement.x + offsetX;
            let newY = selectedElement.y + offsetY;
            
            // キャンバス範囲内に収まるように調整
            if (newX + selectedElement.width > canvasSize.width) {
              newX = Math.max(0, canvasSize.width - selectedElement.width);
            }
            if (newY + selectedElement.height > canvasSize.height) {
              newY = Math.max(0, canvasSize.height - selectedElement.height);
            }
            
            // 新しい要素を作成（全てのプロパティをコピー）
            const copiedElement = {
              ...selectedElement, // 元の要素の全プロパティをコピー
              id: Date.now() + Math.random(), // 新しいユニークIDを生成
              x: newX,
              y: newY
            };
            
            console.log('Creating copied element:', copiedElement);
            
            // 要素配列に追加
            setElements(prevElements => [...prevElements, copiedElement]);
            
            // コピーした要素を選択状態にする
            setSelectedElement(copiedElement);
            
            console.log('Element copied successfully');
          };

          // 選択された要素の内容を更新（シンプル版）
          const updateElementContent = (content) => {
            console.log('updateElementContent called with:', content);
            
            if (!selectedElement) {
              console.log('No selected element, returning early');
              return;
            }

            // シンプルな更新
            setElements(prevElements => {
              return prevElements.map(el => {
                if (el.id === selectedElement.id) {
                  console.log('Updating element content:', el.id, 'with:', content);
                  return { ...el, content: content };
                }
                return el;
              });
            });
            
            // 選択要素も更新
            setSelectedElement(prev => {
              if (prev && prev.id === selectedElement.id) {
                return { ...prev, content: content };
              }
              return prev;
            });
          };

          // テキスト入力のハンドラー（正常動作版）
          const handleContentChange = (e) => {
            console.log('=== handleContentChange START ===');
            
            // preventDefaultは削除（文字入力を阻害するため）
            e.stopPropagation(); // 親への伝播のみ防ぐ
            
            const newValue = e.target.value;
            console.log('New input value:', newValue);
            console.log('Current selectedElement:', selectedElement);
            
            if (!selectedElement) {
              console.error('No selected element when trying to update content');
              return;
            }

            // 要素が存在するかチェック
            const elementExists = elements.some(el => el.id === selectedElement.id);
            if (!elementExists) {
              console.error('Selected element not found in elements array');
              return;
            }
            
            // 直接的な状態更新
            setElements(prevElements => {
              console.log('Updating elements array...');
              const newElements = prevElements.map(el => {
                if (el.id === selectedElement.id) {
                  console.log('Found element to update:', el.id);
                  return { ...el, content: newValue };
                }
                return el;
              });
              console.log('New elements array created');
              return newElements;
            });
            
            // 選択要素の更新
            setSelectedElement(prevSelected => {
              if (prevSelected && prevSelected.id === selectedElement.id) {
                console.log('Updating selected element content');
                return { ...prevSelected, content: newValue };
              }
              return prevSelected;
            });
            
            console.log('=== handleContentChange END ===');
          };

          // キーボードショートカット（シンプル版）
          const handleKeyDown = (e) => {
            console.log('Global keydown:', e.key, 'target:', e.target.tagName, 'type:', e.target.type);
            
            // テキスト入力中は要素削除・コピーを無効にする
            if (e.target.tagName === 'INPUT' && e.target.type === 'text') {
              console.log('Ignoring keydown in text input field');
              return; // テキスト入力フィールド内では何もしない
            }
            
            if (e.key === 'Delete' || e.key === 'Backspace') {
              console.log('Delete key pressed outside input, deleting selected element');
              deleteSelectedElement();
            }
            
            // Ctrl+C でコピー
            if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
              console.log('Copy shortcut pressed');
              e.preventDefault(); // ブラウザのデフォルトコピーを防ぐ
              copySelectedElement();
            }
          };

          // リサイズハンドルの位置を取得
          const getResizeHandle = (element, x, y) => {
            const { x: elX, y: elY, width: elW, height: elH } = element;
            const handleSize = 8;
            const handleOffset = handleSize / 2;
            
            // コーナーハンドル
            if (isPointInRect(x, y, elX - handleOffset, elY - handleOffset, handleSize, handleSize)) return 'tl';
            if (isPointInRect(x, y, elX + elW - handleOffset, elY - handleOffset, handleSize, handleSize)) return 'tr';
            if (isPointInRect(x, y, elX - handleOffset, elY + elH - handleOffset, handleSize, handleSize)) return 'bl';
            if (isPointInRect(x, y, elX + elW - handleOffset, elY + elH - handleOffset, handleSize, handleSize)) return 'br';
            
            // エッジハンドル
            if (isPointInRect(x, y, elX + elW/2 - handleOffset, elY - handleOffset, handleSize, handleSize)) return 't';
            if (isPointInRect(x, y, elX + elW - handleOffset, elY + elH/2 - handleOffset, handleSize, handleSize)) return 'r';
            if (isPointInRect(x, y, elX + elW/2 - handleOffset, elY + elH - handleOffset, handleSize, handleSize)) return 'b';
            if (isPointInRect(x, y, elX - handleOffset, elY + elH/2 - handleOffset, handleSize, handleSize)) return 'l';
            
            return null;
          };
          
          // 点が矩形内にあるかどうかを判定
          const isPointInRect = (x, y, rectX, rectY, rectW, rectH) => {
            return x >= rectX && x <= rectX + rectW && y >= rectY && y <= rectY + rectH;
          };
          
          // リサイズハンドルを描画
          const renderResizeHandles = (element) => {
            if (element !== selectedElement) return null;
            
            const { x, y, width, height } = element;
            const handleSize = 8;
            const handleOffset = handleSize / 2;
            const handles = [
              { id: 'tl', x: x - handleOffset, y: y - handleOffset },
              { id: 'tr', x: x + width - handleOffset, y: y - handleOffset },
              { id: 'bl', x: x - handleOffset, y: y + height - handleOffset },
              { id: 'br', x: x + width - handleOffset, y: y + height - handleOffset },
              { id: 't', x: x + width/2 - handleOffset, y: y - handleOffset },
              { id: 'r', x: x + width - handleOffset, y: y + height/2 - handleOffset },
              { id: 'b', x: x + width/2 - handleOffset, y: y + height - handleOffset },
              { id: 'l', x: x - handleOffset, y: y + height/2 - handleOffset },
            ];
            
            const getCursor = (id) => {
              switch(id) {
                case 'tl': case 'br': return 'nwse-resize';
                case 'tr': case 'bl': return 'nesw-resize';
                case 't': case 'b': return 'ns-resize';
                case 'l': case 'r': return 'ew-resize';
                default: return 'default';
              }
            };
            
            return handles.map(handle => React.createElement('div', {
              key: handle.id,
              style: {
                position: 'absolute',
                left: `${handle.x}px`,
                top: `${handle.y}px`,
                width: `${handleSize}px`,
                height: `${handleSize}px`,
                background: 'white',
                border: '1px solid blue',
                cursor: getCursor(handle.id),
              }
            }));
          };

          // 要素を描画（各タイプの見た目を区別）
          const renderElement = (element) => {
            // タイプごとの見た目設定
            let backgroundColor, borderColor, borderStyle, borderRadius;
            
            switch(element.type) {
              case 'rectangle':
                backgroundColor = '#f5f5f5'; // 薄いグレー
                borderColor = '#666';
                borderStyle = 'solid';
                borderRadius = '0';
                break;
              case 'text':
                backgroundColor = 'rgba(173, 216, 230, 0.3)'; // 薄い青
                borderColor = '#87CEEB';
                borderStyle = 'dashed';
                borderRadius = '0';
                break;
              case 'button':
                backgroundColor = '#e0e0e0';
                borderColor = '#999';
                borderStyle = 'solid';
                borderRadius = '6px';
                break;
              case 'radio':
                backgroundColor = '#fff';
                borderColor = '#666';
                borderStyle = 'solid';
                borderRadius = '4px';
                break;
              case 'checkbox':
                backgroundColor = '#fff';
                borderColor = '#666';
                borderStyle = 'solid';
                borderRadius = '2px';
                break;
              case 'input':
                backgroundColor = '#ffffff';
                borderColor = '#ccc';
                borderStyle = 'solid';
                borderRadius = '3px';
                break;
              case 'image':
                backgroundColor = '#f9f9f9';
                borderColor = '#ddd';
                borderStyle = 'dashed';
                borderRadius = '4px';
                break;
              default:
                backgroundColor = 'transparent';
                borderColor = '#333';
                borderStyle = 'solid';
                borderRadius = '0';
            }

            const style = {
              position: 'absolute',
              left: `${element.x}px`,
              top: `${element.y}px`,
              width: `${element.width}px`,
              height: `${element.height}px`,
              border: element === selectedElement ? '2px solid blue' : `1px ${borderStyle} ${borderColor}`,
              boxSizing: 'border-box',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              background: backgroundColor,
              cursor: 'move',
              userSelect: 'none',
              borderRadius: borderRadius,
              fontSize: Math.min(element.width / 8, element.height / 3, 14) + 'px', // レスポンシブフォントサイズ
            };

            const handleElementClick = (e) => {
              console.log('Element clicked:', element.id, element.type, element.content);
              e.stopPropagation();
              
              // 選択要素を確実に設定
              setSelectedElement({ ...element });
              console.log('Selected element set to:', element);
            };

            const handleElementMouseDown = (e) => {
              console.log('Element mousedown:', element.id);
              // stopPropagationを削除してドラッグを可能にする
              // e.stopPropagation(); // これがドラッグを阻害していた
            };

            // タイプごとの表示内容
            let displayContent;
            switch(element.type) {
              case 'radio':
                displayContent = React.createElement('div', {
                  style: { display: 'flex', alignItems: 'center', gap: '5px' }
                }, [
                  React.createElement('div', {
                    key: 'radio-circle',
                    style: {
                      width: '12px',
                      height: '12px',
                      border: '2px solid #666',
                      borderRadius: '50%',
                      backgroundColor: '#fff',
                      flexShrink: 0
                    }
                  }),
                  React.createElement('span', { key: 'radio-text' }, element.content || 'ラジオボタン')
                ]);
                break;
              case 'checkbox':
                displayContent = React.createElement('div', {
                  style: { display: 'flex', alignItems: 'center', gap: '5px' }
                }, [
                  React.createElement('div', {
                    key: 'checkbox-square',
                    style: {
                      width: '12px',
                      height: '12px',
                      border: '2px solid #666',
                      borderRadius: '2px',
                      backgroundColor: '#fff',
                      flexShrink: 0
                    }
                  }),
                  React.createElement('span', { key: 'checkbox-text' }, element.content || 'チェックボックス')
                ]);
                break;
              case 'image':
                displayContent = React.createElement('div', {
                  style: { display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', gap: '5px' }
                }, [
                  React.createElement('svg', {
                    key: 'image-icon',
                    width: "24", 
                    height: "24", 
                    viewBox: "0 0 24 24", 
                    fill: "none", 
                    stroke: "currentColor", 
                    strokeWidth: "2"
                  }, [
                    React.createElement('rect', { key: 'img-rect', x: "3", y: "3", width: "18", height: "18", rx: "2", ry: "2" }),
                    React.createElement('circle', { key: 'img-circle', cx: "8.5", cy: "8.5", r: "1.5" }),
                    React.createElement('polyline', { key: 'img-line', points: "21 15 16 10 5 21" })
                  ]),
                  React.createElement('span', { 
                    key: 'image-text',
                    style: { fontSize: '10px', textAlign: 'center' }
                  }, element.content || '画像')
                ]);
                break;
              default:
                displayContent = element.content || (element.type === 'rectangle' ? '四角形' : 
                                                   element.type === 'input' ? 'Input' : 
                                                   element.type === 'button' ? 'Button' : 'Text');
            }

            return React.createElement('div', {
              key: element.id,
              style: style,
              onClick: handleElementClick,
              onMouseDown: handleElementMouseDown // stopPropagationを削除したハンドラを使用
            }, displayContent);
          };

          // ワイヤーフレームをJSONエクスポート
          const exportWireframe = () => {
            const projectData = {
              version: "1.0",
              createdAt: new Date().toISOString(),
              canvasSize: canvasSize,
              gridSettings: {
                showGrid: showGrid,
                gridSize: gridSize
              },
              elements: elements
            };
            
            const data = JSON.stringify(projectData, null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
            a.download = `wireframe_${timestamp}.json`;
            a.click();
            URL.revokeObjectURL(url);
          };

          // JSONファイルからワイヤーフレームを読み込み
          const importWireframe = () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
              const file = e.target.files[0];
              if (!file) return;
              
              const reader = new FileReader();
              reader.onload = (e) => {
                try {
                  const projectData = JSON.parse(e.target.result);
                  
                  // データの検証
                  if (projectData.elements && Array.isArray(projectData.elements)) {
                    setElements(projectData.elements);
                    console.log('Elements loaded:', projectData.elements.length);
                  }
                  
                  if (projectData.canvasSize) {
                    setCanvasSize(projectData.canvasSize);
                    console.log('Canvas size loaded:', projectData.canvasSize);
                  }
                  
                  if (projectData.gridSettings) {
                    setShowGrid(projectData.gridSettings.showGrid || false);
                    setGridSize(projectData.gridSettings.gridSize || 20);
                    console.log('Grid settings loaded:', projectData.gridSettings);
                  }
                  
                  // 選択状態をクリア
                  setSelectedElement(null);
                  setDraggedElement(null);
                  setIsDrawing(false);
                  setResizing(null);
                  
                  alert('ワイヤーフレームを正常に読み込みました！');
                } catch (error) {
                  console.error('JSON parse error:', error);
                  alert('ファイルの読み込みに失敗しました。正しいJSONファイルを選択してください。');
                }
              };
              reader.readAsText(file);
            };
            input.click();
          };

          // 新規プロジェクト作成（確認付き）
          const newProject = () => {
            if (elements.length > 0) {
              const confirmed = confirm('現在の作業内容が失われます。新規プロジェクトを作成しますか？');
              if (!confirmed) return;
            }
            
            setElements([]);
            setSelectedElement(null);
            setDraggedElement(null);
            setIsDrawing(false);
            setResizing(null);
            setCanvasSize({ width: 1200, height: 800 });
            setShowGrid(true);
            setGridSize(20);
            setZoom(1);
            setSelectedElementType('rectangle'); // 選択要素タイプもリセット
            
            console.log('New project created');
          };

          // 画像として出力
          const exportAsImage = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // キャンバスサイズを設定
            canvas.width = canvasSize.width;
            canvas.height = canvasSize.height;
            
            // 背景を白で塗りつぶし
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // グリッドを描画（表示されている場合）
            if (showGrid) {
              ctx.strokeStyle = '#ADD8E6'; // 薄い水色
              ctx.lineWidth = 1;
              ctx.globalAlpha = 0.5;
              
              // 縦線を描画
              for (let x = gridSize; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
              }
              
              // 横線を描画
              for (let y = gridSize; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
              }
              
              ctx.globalAlpha = 1; // 透明度をリセット
            }
            
            // 要素を描画
            elements.forEach(element => {
              const { x, y, width, height, type, content } = element;
              
              // 要素の境界線と背景を描画
              let backgroundColor, borderColor, borderStyle;
              
              switch(type) {
                case 'rectangle':
                  backgroundColor = '#f5f5f5';
                  borderColor = '#666';
                  break;
                case 'text':
                  backgroundColor = 'rgba(173, 216, 230, 0.3)';
                  borderColor = '#87CEEB';
                  break;
                case 'button':
                  backgroundColor = '#e0e0e0';
                  borderColor = '#999';
                  break;
                case 'radio':
                case 'checkbox':
                  backgroundColor = '#fff';
                  borderColor = '#666';
                  break;
                case 'input':
                  backgroundColor = '#ffffff';
                  borderColor = '#ccc';
                  break;
                case 'image':
                  backgroundColor = '#f9f9f9';
                  borderColor = '#ddd';
                  break;
                default:
                  backgroundColor = 'transparent';
                  borderColor = '#333';
              }
              
              // 背景を描画
              if (backgroundColor !== 'transparent') {
                ctx.fillStyle = backgroundColor;
                ctx.fillRect(x, y, width, height);
              }
              
              // 境界線を描画
              ctx.strokeStyle = borderColor;
              ctx.lineWidth = 1;
              
              if (type === 'text') {
                // テキスト要素は破線
                ctx.setLineDash([5, 5]);
              } else if (type === 'image') {
                // 画像要素は破線
                ctx.setLineDash([3, 3]);
              } else {
                ctx.setLineDash([]); // 実線
              }
              
              ctx.strokeRect(x, y, width, height);
              ctx.setLineDash([]); // 破線をリセット
              
              // テキストを描画
              if (content) {
                ctx.fillStyle = '#333';
                const fontSize = Math.min(width / 8, height / 3, 14);
                ctx.font = `${fontSize}px Arial, sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // 特殊要素の描画
                if (type === 'radio') {
                  // ラジオボタンのアイコンを描画
                  const iconSize = 12;
                  const iconX = x + 10;
                  const iconY = y + height / 2;
                  
                  ctx.strokeStyle = '#666';
                  ctx.lineWidth = 2;
                  ctx.beginPath();
                  ctx.arc(iconX, iconY, iconSize / 2, 0, 2 * Math.PI);
                  ctx.stroke();
                  
                  // テキストを右側に描画
                  ctx.fillText(content, x + 30 + (width - 30) / 2, y + height / 2);
                } else if (type === 'checkbox') {
                  // チェックボックスのアイコンを描画
                  const iconSize = 12;
                  const iconX = x + 10;
                  const iconY = y + height / 2 - iconSize / 2;
                  
                  ctx.strokeStyle = '#666';
                  ctx.lineWidth = 2;
                  ctx.strokeRect(iconX - iconSize / 2, iconY, iconSize, iconSize);
                  
                  // テキストを右側に描画
                  ctx.fillText(content, x + 30 + (width - 30) / 2, y + height / 2);
                } else if (type === 'image') {
                  // 画像アイコンとテキストを描画
                  const iconSize = 24;
                  const iconX = x + width / 2;
                  const iconY = y + height / 2 - 10;
                  
                  // シンプルな画像アイコンを描画
                  ctx.strokeStyle = '#666';
                  ctx.lineWidth = 2;
                  ctx.strokeRect(iconX - iconSize / 2, iconY - iconSize / 2, iconSize, iconSize);
                  
                  // 小さな円（画像内の要素として）
                  ctx.beginPath();
                  ctx.arc(iconX - 5, iconY - 5, 3, 0, 2 * Math.PI);
                  ctx.stroke();
                  
                  // テキストを下に描画
                  ctx.font = `10px Arial, sans-serif`;
                  ctx.fillText(content, iconX, iconY + iconSize / 2 + 15);
                } else {
                  // 通常のテキスト描画
                  ctx.fillText(content, x + width / 2, y + height / 2);
                }
              }
            });
            
            // 画像をダウンロード
            const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
            canvas.toBlob((blob) => {
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = `wireframe_image_${timestamp}.png`;
              a.click();
              URL.revokeObjectURL(url);
            }, 'image/png');
          };

          return React.createElement('div', {
            className: "flex flex-col h-screen",
            onKeyDown: handleKeyDown,
            tabIndex: "0"
          }, [
            React.createElement('div', {
              key: 'header',
              className: "p-4 bg-gray-800 text-white flex justify-between items-center"
            }, [
              React.createElement('h1', {
                key: 'title',
                className: "text-lg font-bold"
              }, 'シンプルワイヤーフレーム作成ツール'),
              React.createElement('div', {
                key: 'controls',
                className: "flex items-center space-x-4"
              }, [
                React.createElement('div', {
                  key: 'canvas-size',
                  className: "flex items-center space-x-2"
                }, [
                  React.createElement('label', {
                    key: 'canvas-size-label',
                    className: "text-sm"
                  }, 'キャンバスサイズ:'),
                  React.createElement('select', {
                    key: 'canvas-size-select',
                    className: "px-2 py-1 text-black rounded text-sm",
                    onChange: (e) => {
                      const preset = canvasPresets.find(p => p.name === e.target.value);
                      if (preset) handleCanvasSizeChange(preset);
                    }
                  }, canvasPresets.map((preset, index) => 
                    React.createElement('option', {
                      key: `preset-${index}`,
                      value: preset.name
                    }, preset.name)
                  ))
                ]),
                // グリッド関連のコントロールを追加
                React.createElement('div', {
                  key: 'grid-controls',
                  className: "flex items-center space-x-2"
                }, [
                  React.createElement('button', {
                    key: 'grid-toggle',
                    className: `px-3 py-1 rounded text-sm ${showGrid ? 'bg-blue-500 text-white' : 'bg-gray-300 text-gray-700'}`,
                    onClick: () => setShowGrid(!showGrid)
                  }, showGrid ? 'グリッド ON' : 'グリッド OFF'),
                  React.createElement('select', {
                    key: 'grid-size-select',
                    className: "px-2 py-1 text-black rounded text-sm",
                    value: gridSize,
                    onChange: (e) => setGridSize(parseInt(e.target.value)),
                    disabled: !showGrid
                  }, gridSizeOptions.map((size, index) => 
                    React.createElement('option', {
                      key: `grid-size-${index}`,
                      value: size
                    }, `${size}px`)
                  ))
                ]),
                React.createElement('div', {
                  key: 'zoom',
                  className: "flex items-center space-x-2"
                }, [
                  React.createElement('label', {
                    key: 'zoom-label',
                    className: "text-sm"
                  }, 'ズーム:'),
                  React.createElement('select', {
                    key: 'zoom-select',
                    className: "px-2 py-1 text-black rounded text-sm",
                    value: Math.round(zoom * 100),
                    onChange: (e) => setZoom(parseInt(e.target.value) / 100)
                  }, [25, 50, 75, 100, 125, 150, 200].map((value, index) =>
                    React.createElement('option', {
                      key: `zoom-${index}`,
                      value: value
                    }, `${value}%`)
                  ))
                ]),
                React.createElement('div', {
                  key: 'size-info',
                  className: "text-sm"
                }, `${canvasSize.width} x ${canvasSize.height}`)
              ])
            ]),
            React.createElement('div', {
              key: 'main',
              className: "flex flex-1 overflow-hidden"
            }, [
              React.createElement('div', {
                key: 'palette',
                className: "w-48 bg-gray-100 p-4 overflow-y-auto"
              }, [
                React.createElement('h2', {
                  key: 'palette-title',
                  className: "font-bold mb-2"
                }, '要素パレット'),
                React.createElement('div', {
                  key: 'palette-info',
                  className: "text-xs text-gray-600 mb-2 p-2 bg-yellow-50 border border-yellow-200 rounded"
                }, [
                  React.createElement('div', { key: 'info-1' }, '• クリックで要素を選択'),
                  React.createElement('div', { key: 'info-2' }, '• ドラッグでキャンバスに配置'),
                  React.createElement('div', { key: 'info-3' }, '• キャンバス描画で選択中の要素を作成')
                ]),
                React.createElement('div', {
                  key: 'elements',
                  className: "space-y-2"
                }, elementTypes.map((el, index) =>
                  React.createElement('div', {
                    key: `element-${index}`,
                    className: `p-2 border border-gray-300 rounded cursor-grab text-center transition-colors ${
                      selectedElementType === el.type 
                        ? 'bg-blue-100 border-blue-400 text-blue-800' 
                        : 'bg-white hover:bg-gray-50'
                    }`,
                    draggable: true,
                    onDragStart: (e) => handleElementDragStart(el.type, e),
                    onClick: () => {
                      setSelectedElementType(el.type);
                      console.log('Selected element type:', el.type);
                    }
                  }, [
                    React.createElement('div', { 
                      key: 'label',
                      className: "font-medium"
                    }, el.label),
                    selectedElementType === el.type && React.createElement('div', {
                      key: 'selected-indicator',
                      className: "text-xs text-blue-600 mt-1"
                    }, '✓ 選択中')
                  ])
                )),
                React.createElement('div', {
                  key: 'controls',
                  className: "mt-4"
                }, [
                  React.createElement('div', {
                    key: 'file-operations',
                    className: "space-y-2 mb-4"
                  }, [
                    React.createElement('div', {
                      key: 'file-label',
                      className: "text-sm font-semibold text-gray-700 mb-1"
                    }, 'ファイル操作'),
                    React.createElement('button', {
                      key: 'new-project',
                      className: "w-full p-2 bg-purple-500 text-white rounded text-sm",
                      onClick: newProject
                    }, '新規プロジェクト'),
                    React.createElement('button', {
                      key: 'import',
                      className: "w-full p-2 bg-orange-500 text-white rounded text-sm",
                      onClick: importWireframe
                    }, 'プロジェクト読み込み'),
                    React.createElement('button', {
                      key: 'export-json',
                      className: "w-full p-2 bg-blue-500 text-white rounded text-sm",
                      onClick: exportWireframe
                    }, 'プロジェクト保存')
                  ]),
                  React.createElement('div', {
                    key: 'edit-operations',
                    className: "space-y-2 mb-4"
                  }, [
                    React.createElement('div', {
                      key: 'edit-label',
                      className: "text-sm font-semibold text-gray-700 mb-1"
                    }, '編集操作'),
                    React.createElement('button', {
                      key: 'copy',
                      className: `w-full p-2 text-white rounded text-sm ${selectedElement ? 'bg-indigo-500 hover:bg-indigo-600' : 'bg-gray-400 cursor-not-allowed'}`,
                      onClick: copySelectedElement,
                      disabled: !selectedElement
                    }, selectedElement ? '選択要素をコピー' : 'コピー（要素を選択）'),
                    React.createElement('button', {
                      key: 'delete',
                      className: `w-full p-2 text-white rounded text-sm ${selectedElement ? 'bg-red-500 hover:bg-red-600' : 'bg-gray-400 cursor-not-allowed'}`,
                      onClick: deleteSelectedElement,
                      disabled: !selectedElement
                    }, selectedElement ? '選択要素を削除' : '削除（要素を選択）')
                  ]),
                  React.createElement('div', {
                    key: 'export-operations',
                    className: "space-y-2"
                  }, [
                    React.createElement('div', {
                      key: 'export-label',
                      className: "text-sm font-semibold text-gray-700 mb-1"
                    }, '出力操作'),
                    React.createElement('button', {
                      key: 'export-image',
                      className: "w-full p-2 bg-green-500 text-white rounded text-sm",
                      onClick: exportAsImage
                    }, 'PNG画像出力')
                  ])
                ])
              ]),
              React.createElement('div', {
                key: 'canvas-container',
                className: "flex-1 bg-gray-200 border-l border-r border-gray-300 overflow-auto",
                style: { padding: '20px' }
              }, 
                React.createElement('div', {
                  className: "bg-white shadow-lg border border-gray-400",
                  ref: canvasRef,
                  onMouseDown: handleCanvasMouseDown,
                  onMouseMove: handleCanvasMouseMove,
                  onMouseUp: handleCanvasMouseUp,
                  onMouseLeave: () => {
                    setDraggedElement(null);
                    setIsDrawing(false);
                    setResizing(null);
                  },
                  onDragOver: handleCanvasDragOver,
                  onDrop: handleCanvasDrop,
                  style: { 
                    position: 'relative',
                    width: `${canvasSize.width * zoom}px`,
                    height: `${canvasSize.height * zoom}px`,
                    transform: `scale(${zoom})`,
                    transformOrigin: 'top left',
                    cursor: isDrawing ? 'crosshair' : 'default',
                    // グリッドの背景画像を条件付きで適用
                    backgroundImage: showGrid ? generateGridPattern() : 'none',
                    backgroundSize: showGrid ? `${gridSize}px ${gridSize}px` : 'auto',
                    backgroundPosition: '0 0'
                  }
                }, [
                  ...elements.map(renderElement),
                  selectedElement && renderResizeHandles(selectedElement),
                  draggedElement?.isPreview && React.createElement('div', {
                    key: 'preview',
                    style: {
                      position: 'absolute',
                      left: `${draggedElement.width > 0 ? draggedElement.x : draggedElement.x + draggedElement.width}px`,
                      top: `${draggedElement.height > 0 ? draggedElement.y : draggedElement.y + draggedElement.height}px`,
                      width: `${Math.abs(draggedElement.width)}px`,
                      height: `${Math.abs(draggedElement.height)}px`,
                      border: '1px dashed blue',
                      background: 'rgba(0, 0, 255, 0.1)',
                    }
                  })
                ])
              ),
              React.createElement('div', {
                key: 'properties',
                className: "w-64 bg-gray-100 p-4 overflow-y-auto"
              }, [
                React.createElement('h2', {
                  key: 'prop-title',
                  className: "font-bold mb-2"
                }, 'プロパティ'),
                React.createElement('div', {
                  key: 'canvas-info',
                  className: "mb-4 p-2 bg-blue-50 border border-blue-200 rounded text-sm"
                }, [
                  React.createElement('div', { key: 'info-title' }, React.createElement('strong', {}, 'プロジェクト情報')),
                  React.createElement('div', { key: 'size' }, `キャンバス: ${canvasSize.width} x ${canvasSize.height}`),
                  React.createElement('div', { key: 'zoom' }, `ズーム: ${Math.round(zoom * 100)}%`),
                  React.createElement('div', { key: 'grid' }, `グリッド: ${showGrid ? `ON (${gridSize}px)` : 'OFF'}`),
                  React.createElement('div', { key: 'selected-type' }, `描画要素: ${elementTypes.find(t => t.type === selectedElementType)?.label || selectedElementType}`),
                  React.createElement('div', { key: 'count' }, `要素数: ${elements.length}`),
                  React.createElement('div', { 
                    key: 'warning',
                    style: { color: '#dc2626', fontSize: '11px', marginTop: '4px' }
                  }, '⚠️ 定期的にプロジェクト保存してください')
                ]),
                selectedElement ? React.createElement('div', {
                  key: 'element-props',
                  className: "space-y-2"
                }, [
                  React.createElement('div', { key: 'type' }, [
                    React.createElement('label', { className: "block text-sm text-gray-600" }, 'タイプ'),
                    React.createElement('div', { className: "p-2 bg-white border border-gray-300 rounded" }, selectedElement.type)
                  ]),
                  React.createElement('div', { key: 'x' }, [
                    React.createElement('label', { className: "block text-sm text-gray-600" }, 'X座標'),
                    React.createElement('div', { className: "p-2 bg-white border border-gray-300 rounded" }, Math.round(selectedElement.x))
                  ]),
                  React.createElement('div', { key: 'y' }, [
                    React.createElement('label', { className: "block text-sm text-gray-600" }, 'Y座標'),
                    React.createElement('div', { className: "p-2 bg-white border border-gray-300 rounded" }, Math.round(selectedElement.y))
                  ]),
                  React.createElement('div', { key: 'width' }, [
                    React.createElement('label', { className: "block text-sm text-gray-600" }, '幅'),
                    React.createElement('div', { className: "p-2 bg-white border border-gray-300 rounded" }, Math.round(selectedElement.width))
                  ]),
                  React.createElement('div', { key: 'height' }, [
                    React.createElement('label', { className: "block text-sm text-gray-600" }, '高さ'),
                    React.createElement('div', { className: "p-2 bg-white border border-gray-300 rounded" }, Math.round(selectedElement.height))
                  ]),
                  // すべての要素タイプで内容編集を可能に
                  (selectedElement.type === 'text' || 
                   selectedElement.type === 'button' || 
                   selectedElement.type === 'input' || 
                   selectedElement.type === 'rectangle' || 
                   selectedElement.type === 'radio' || 
                   selectedElement.type === 'checkbox' || 
                   selectedElement.type === 'image') && React.createElement('div', { key: 'content' }, [
                    React.createElement('label', { 
                      key: 'content-label',
                      className: "block text-sm text-gray-600" 
                    }, '内容'),
                    React.createElement('input', {
                      key: `content-input-${selectedElement.id}`, // IDベースのユニークなkey
                      type: "text",
                      className: "w-full p-2 border border-gray-300 rounded",
                      value: selectedElement.content || '',
                      onChange: handleContentChange,
                      onKeyDown: (e) => {
                        console.log('Input keydown:', e.key);
                        // Delete/Backspaceキーの伝播のみ防ぐ
                        if (e.key === 'Delete' || e.key === 'Backspace') {
                          e.stopPropagation();
                        }
                        if (e.key === 'Enter') {
                          e.target.blur(); // Enterでフォーカスを外す
                        }
                      },
                      placeholder: selectedElement.type === 'image' ? "画像の説明テキスト..." : 
                                  selectedElement.type === 'rectangle' ? "四角形内のテキスト..." : 
                                  selectedElement.type === 'radio' ? "ラジオボタンのラベル..." : 
                                  selectedElement.type === 'checkbox' ? "チェックボックスのラベル..." : 
                                  "テキストを入力...",
                      autoComplete: "off"
                    })
                  ])
                ]) : React.createElement('div', {
                  key: 'no-selection',
                  className: "text-gray-500"
                }, '要素を選択してください')
              ])
            ]),
            React.createElement('div', {
              key: 'footer',
              className: "p-2 bg-gray-200 text-sm text-gray-600"
            }, [
              React.createElement('div', {
                key: 'footer-grid',
                className: "grid grid-cols-2 gap-4"
              }, [
                React.createElement('div', { key: 'left-guide' }, [
                  React.createElement('div', { key: 'guide-title' }, React.createElement('strong', {}, '操作ガイド：')),
                  React.createElement('div', { key: 'guide-1' }, '・パレットの要素をクリックして選択、ドラッグでキャンバスに配置'),
                  React.createElement('div', { key: 'guide-2' }, '・キャンバス上でドラッグすると選択中の要素タイプで描画'),
                  React.createElement('div', { key: 'guide-3' }, '・要素をクリックして選択、Deleteキーで削除'),
                  React.createElement('div', { key: 'guide-4' }, '・選択した要素をドラッグして移動'),
                  React.createElement('div', { key: 'guide-5' }, '・選択した要素の青い四角のハンドルをドラッグしてサイズ変更'),
                  React.createElement('div', { key: 'guide-6' }, '・コピーボタンまたはCtrl+Cで選択要素を複製'),
                  React.createElement('div', { key: 'guide-7' }, '・グリッドボタンでガイドライン表示/非表示の切り替え')
                ]),
                React.createElement('div', { key: 'right-guide' }, [
                  React.createElement('div', { key: 'file-title' }, React.createElement('strong', {}, 'ファイル管理：')),
                  React.createElement('div', { key: 'file-1' }, '・プロジェクト保存でJSONファイルに保存'),
                  React.createElement('div', { key: 'file-2' }, '・プロジェクト読み込みで作業を再開'),
                  React.createElement('div', { key: 'file-3' }, '・新規プロジェクトで最初から開始'),
                  React.createElement('div', { key: 'file-4' }, '・PNG画像出力でワイヤーフレームを画像化'),
                  React.createElement('div', { key: 'file-5' }, React.createElement('span', { style: { color: '#dc2626' } }, '※ページを更新すると作業内容が失われます'))
                ])
              ])
            ])
          ]);
        };

        // React 18のcreateRoot APIを使用
        const container = document.getElementById('root');
        const root = ReactDOM.createRoot ? ReactDOM.createRoot(container) : ReactDOM.render;
        
        if (ReactDOM.createRoot) {
          root.render(React.createElement(WireframeBuilder));
        } else {
          // React 17以下のフォールバック
          ReactDOM.render(React.createElement(WireframeBuilder), container);
        }
    </script>
</body>
</html>
